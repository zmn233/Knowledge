# 算法题总结
> 做了这么久的算法题，感觉自己好像没什么长进，于是乎决定每天对做过的算法题进行一个总结，找到通用的解决方法
### -leetCode 初级算法
#### 0. 设计一个函数，向其传入一个数组和一个 target，在数组中找到两个值，使两数之和等于 target
这个题在剑指Offer做过类似的，不过到道题是传入一个“递增数组”，因此直接定义两个指针分别为 low 和 high 向中间找就可以了。看到这道题的时候就会陷入一种“啊不然我也先排个序然后再找”的感觉，其实不用的，排序最次也要 nlogn 的时间复杂度，这道题其实只用 O(n) 就可以做出来，遍历数组，每出现一个数就向 hash 里将当前数和索引以键值对的形式存进去，存进去之前先查看 hash 中是否存放有 (target - now)，如果有的话直接返回，很简单了。
### 19.2.27 --leetCode·头条
#### 1. 无重复字符的最长子串
给定一个字符串，请你找出其中不含有重复字符的 最长子串 的长度。
解决方法：从前往后遍历字符串，用两个下标 start 和 end 记录当前不重复子串的位置。有一点滑动窗口的意思，不过这个窗口的长度不是固定的，同时需要一个 hash 对象来记录出现过的字符，每碰到一个出现过的字符，就把 start 置为该字符上次出现的位置（没错，hash里存放的是字符索引，这个位置是 end 遍历得到的），并且在遍历过程中需要不断更新最长子串的长度，最后将结果返回。
#### 2. 最长公共前缀
编写一个函数来查找字符串数组中的最长公共前缀。
以第一个字符串为基准，对后面的字符串进行遍历，利用一个 index 记录当前比较的前缀下标，跳出循环的条件要么是 index 超出了第一个字符串长度或者某一个字符串长度，要么就是 index 位不满足相等。在循环中直接 return 即可
#### 3. 字符串的排列
给定两个字符串 s1 和 s2，写一个函数来判断 s2 是否包含 s1 的排列。
换句话说，第一个字符串的排列之一是第二个字符串的子串。
这道题我自己做的时候想的是找出第一个字符串的所有排列然后去比较，结果人题上写字符串长度在 [1, 10000] 之间，妥妥超时。因此只能换一个思路，这道题同样是利用滑动窗口的思想，窗口大小是固定的，为 s1 的长度，该窗口在 s2 上滑动，如果满足窗口中出现的字符以及出现次数和 s1 相等，则返回 true
### 19.2.28 --leetCode·头条
#### 4. 字符串相乘
给定两个以字符串形式表示的非负整数 num1 和 num2，返回 num1 和 num2 的乘积，它们的乘积也表示为字符串形式。
题上规定两个字符串长度在 [1, 110] 之间，因此其实还是个大数乘法，如果直接把字符串转换为数字（当然题上也规定了不能这么做）会产生溢出。
因此同样遍历字符串，拿出一个数组用于保存结果，将对应位置上的字符串进行相乘（转换时可以通过 string.charCodeAt(i) - 48 拿到字符对应的数字）,这一次遍历先不管进位
然后再次遍历，这次将进位加上
最后一次遍历，将结果转换为字符串
#### 5. 翻转字符串里的单词
给定一个字符串，逐个翻转字符串中的每个单词。
这题原来在牛客做过类似的，无非就是整个字符串翻转，再对单词进行翻转，不过这道题还规定了不能有多余的空格（输入可以多余，但输出不可以）
因此用从后往前遍历的思想，但是单词不需要翻转，所以单词是“倒叙遍历，正序相加”，有点数组往里 unshift 的感觉
### 19.3.1 --leetCode·头条
> 每天做完算法题就像吃了屎一样，很难受但没有办法，还没法跟别人说
#### 6. 简化路径
以 Unix 风格给出一个文件的绝对路径，你需要简化它。或者换句话说，将其转换为规范路径。
这个题其实很简单了，不过我也没有想出来。输入的字符串看上去很复杂，其实不然。我们要转换路径，只需要拿出路径中我们关注的信息即可，也就是文件夹名称和'.' 以及 '..'，那么直接将字符串通过 '/' 隔开，可以用一个队列存储结果，如果当前项非空或者是'.'，那么什么都不用做，如果为'..'，那么对队列进行 pop(前提是队列里有东西)，否则就将当前项 push 进队列当中。
最后只要在数组每一项之前加上 '/' 输出即可。
#### 7. 复原IP地址
给定一个只包含数字的字符串，复原它并返回所有可能的 IP 地址格式。
这个题首先要知道 IP地址 的格式是什么样的。其实就是 x.x.x.x 这样的格式，最少4位，最多12位，并且不能以0开头，这道题就是一个一个去试。先试一试当前项是一位数可不可以，再试一试两位数，然后是三位数(三位数不可超过255),，递归终点就是①剩下的字符数已经不足以用来分组了 ②剩下的字符数超出了限制 ③满足条件，是可能的IP地址，此时就放进结果数组中。
#### 8. 三数之和
给定一个包含 n 个整数的数组 nums，判断 nums 中是否存在三个元素 a，b，c ，使得 a + b + c = 0 ？找出所有满足条件且不重复的三元组。
这个题原先做过类似的"两数之和",思路很简单嘛，可以通过排序，然后先固定一个，剩下的从两边往里找，还可以先固定一个，同样利用 hash 的方法来找。麻烦的是“不能重复”这四个字，我一旦长时间没有做出来一道题整个人就会很浮躁，一浮躁就更做不出来了。一想到可能真的会考这样的题，我突然很绝望，真的。
### 19.3.2 --leetCode·头条
#### 9.岛屿的最大面积
给定一个包含了一些 0 和 1的非空二维数组 grid , 一个 岛屿 是由四个方向 (水平或垂直) 的 1 (代表土地) 构成的组合。你可以假设二维矩阵的四个边缘都被水包围着。
这道题就是一个图的遍历问题，找到图中连通度最大的那个值。我可是自己写出来的哦~叉会儿腰。图的遍历可以用 BFS 或者是 DFS，跟树的遍历其实是差不多的。这道题我用了 BFS，就是固定一个节点，然后去找它能通到的所有节点。对访问过的节点记录一个 visited 数组，如果当前节点能访问则去它的上，下，右，左继续找看是否连通。递归边界就是①到了数组的边界 ②不连通 ③已经被访问过。
#### 10.最长连续递增序列
给定一个未经排序的整数数组，找到最长且连续的的递增序列。
这道题也很简单，在一个未排序的数组中找到最长的递增序列，那么肯定需要对数组进行遍历了。遍历过程中记录最大值最后返回即可。
#### 11. 搜索旋转排序数组
这道题和牛客网上那道“在旋转数组上查找最小值”是差不多的。都采用了二分查找的形式，找最小值的那道题中，我们可以控制left， right两个指针分别指向左边的递增数组以及右边的递增数组，当 right - left = 1 时，表示两个指针相邻，此时right指向的就是最小的数，然后将其返回即可。
这道题要稍微复杂一点。说复杂也不复杂（你到底在说什么），最主要的是要分析条件并且分析准确，分析 mid，target，left，right四者之间的关系，数组中为两个递增的数列，并且左边数列比右边数列大，抓住这个特点慢慢分析就可以做出来了。
### 19.3.3 --leetCode·头条
#### 12.数组中的第K个最大元素
在未排序的数组中找到第 k 个最大的元素。请注意，你需要找的是数组排序后的第 k 个最大的元素，<span style="font-weight: bold">而不是第 k 个不同</span>的元素。
这道题很简单了，不过一定要仔细读题，人家题上说了，不是第 k 个不同的元素。所以只需排序即可，不用再去重了。
#### 13. 最长连续序列
给定一个未排序的整数数组，找出最长连续序列的长度。
要求算法的时间复杂度为 O(n)。
这道题同样的也要仔细读题，时间复杂度为 o(n)，说明不可以用排序算法了，只能用空间换时间，声明一个哈希表将出现过的数字进行记录，每次遍历一个 num 先判断其相邻数字是否出现过，当前所在的序列长度为 left + right + 1，然后去更新 num - left 以及 num + right。每遍历一次也需要更新 max，最后输出 max 即可。
#### 14. 第 K 个排列
给出集合 [1,2,3,…,n]，其所有元素共有 n! 种排列。
按大小顺序列出所有排列情况，并一一标记，当 n = 3 时, 所有排列如下：
"123"
"132"
"213"
"231"
"312"
"321"
给定 n 和 k，返回第 k 个排列。
这个题也是全排列问题，不过同样的我们也不能使用全排列，哪怕是在每次第k个就进行 return，会造成堆栈的溢出。这道题只能使用数学的解法。一位数字一位数字地固定下来。最后返回结果。
### 19.3.5 --leetCode·头条
#### 15.朋友圈
班上有 N 名学生。其中有些人是朋友，有些则不是。他们的友谊具有是传递性。如果已知 A 是 B 的朋友，B 是 C 的朋友，那么我们可以认为 A 也是 C 的朋友。所谓的朋友圈，是指所有朋友的集合。
给定一个 N * N 的矩阵 M，表示班级中学生之间的朋友关系。如果M[i][j] = 1，表示已知第 i 个和 j 个学生互为朋友关系，否则为不知道。你必须输出所有学生中的已知的朋友圈总数。
这道题和那道“求最大岛屿面积”差不多，都是图的遍历，不过一道是要求出图里最大区域1的个数，一个是要数出这些岛屿的个数。其实一个一个遍历就很简单了，首先遍历第一个人，然后去遍历他的朋友，再去遍历他朋友的朋友，结束后这块“岛屿”就算是遍历完了，要从下一个没有被遍历过的人开始，最后输出“岛屿”总数。
#### 16.合并区间
给出一个区间的集合，请合并所有重叠的区间。
这道题就是判断当前集合的第一位和上一个集合的后一位有无重叠部分，如果有则合并。我刚开始以为区间都是以数组的形式表示的，结果后来才发现是有一个 interval 实例用以表示当前区间，start 表示区间看是， end 表示区间结束，这才导致了我的错误。所以说读题很重要！！！！
#### 17.接雨水
给定 n 个非负整数表示每个宽度为 1 的柱子的高度图，计算按此排列的柱子，下雨之后能接多少雨水。
这个题稍微抽象一点，我自己是没有找到解决方法的。看了别人的解决方法之后就恍然大悟了：当前这一项能否接水取决于左右两边是否有比我高的(>=)的块，因此我需要记录每一项他左边和右边的最大值，Math.min(left, right) 和我当前项的高度进行比较，如果大于，则说明可以接水，如果小于，则直接取0即可。
### 19.3.6 --leetCode·头条
#### 18.合并两个有序链表
将两个有序链表合并为一个新的有序链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。 
这个题真的很简单了，也做过挺多回的。我首先判断第一个节点谁大谁小，确定了第一个节点再往后比较，结果看人家的方法发现居然可以更明了。那就是直接生成一个头结点，然后去遍历两个链表，找到指针指向的那个节点更小的一方，最后返回的时候直接返回我们新生成的头结点.next 即可。这样真的很聪明诶！避免外面多余的代码
还可以用递归进行！这样也不用比较头结点大小，因为节点的比较本身就存在于每一步当中。大家都真是太聪明了。
#### 19. 反转链表
这个题也没啥说的，做了三四遍了，用循环就可以简单解决。
#### 20.两数相加
给出两个 非空 的链表用来表示两个非负的整数。其中，它们各自的位数是按照 逆序 的方式存储的，并且它们的每个节点只能存储 一位 数字。
如果，我们将这两个数相加起来，则会返回一个新的链表来表示它们的和。
您可以假设除了数字 0 之外，这两个数都不会以 0 开头。
今天最主要就是栽在这道题上了，本来以为前面那两道题那么简单，今天可以多做几道，谁知道这道题生生用掉了我一个小时的时间，还让我的电脑内存爆掉然后自己最后不得不重启电脑。。。anyway，还是应该怪我自己，写代码太不熟练。这道题的坑一个是我没太读懂题，总觉得测试用例和题干说的是反的；第二就是这也涉及到一个大数相加的问题，如果直接相加会有溢出的危险，所以还是只能遍历链表，一个一个加，有进位把进位也加上。这道题同样也自己新生成一个节点，最后返回 newNode.next
### 19.3.7 --leetCode·头条
#### 21.排序链表
在 O(n log n) 时间复杂度和常数级空间复杂度下，对链表进行排序。
这道题如果不规定“常数级空间”的话，我应该会遍历整个链表，然后把他们的值放到数组中。排序后再一一生成新节点哈哈哈。看了别人的解法后，发现大神真的就是大神啊，将链表进行归并排序即可。归并排序我原来只用在数组上，就是将数组递归地分成两部分，直到每个数组只有一项，最后两两进行排序。转换到链表也是一样的，首先将链表分成两部分（用快慢指针，一个走一步，一个走两步，快指针指到null时，慢指针指向的节点就是第二个链表的开头了），递归到最底层之后就是有序链表的排序，又转换为了做过的题！YES！
#### 22.环形链表 II
给定一个链表，返回链表开始入环的第一个节点。 如果链表无环，则返回 null。
为了表示给定链表中的环，我们使用整数 pos 来表示链表尾连接到链表中的位置（索引从 0 开始）。 如果 pos 是 -1，则在该链表中没有环。
说明：不允许修改给定的链表。
这个题也是做过的，同样定义两个快慢指针，相遇之后让其中一个链表走到原点，然后按相同的速度向前进，再一次相遇时就是环的入口了。不过要记得判断是否有环。也就是在第一次相遇前看快指针会不会走到 null
#### 23.相交链表
编写一个程序，找到两个单链表相交的起始节点。
这个题也是做过的啦！遍历两个链表得到他们的长度，然后让长的那个链表走 diff 步，之后再一起走，相遇时就是相交节点了。
#### 24. 合并K个排序链表
合并 k 个排序链表，返回合并后的排序链表。请分析和描述算法的复杂度。
这个题在面经里面看见过，在 LeetCode 里还被标记为困难呢！结果我！做！出！来！了！就是遍历链表啦，让 list1 等于上一个排好序的链表，跟当前链表 list2 进行排序，也转换成了有序链表的排序问题。
觉得自己信心大增了真的（虽然被招商刷了，不过！头条在前方等着我呢！）
### 19.3.10 --leetCode·头条
#### 25. 二叉树的最近公共祖先
给定一个二叉树, 找到该树中两个指定节点的最近公共祖先。
这道题我也不知道该怎么总结它的方法，总之也是对树进行遍历。找到当前根节点的左右子树是否包含p，q并返回查找结果。如果左右两边返回值都不为 null，则表示q，p分别位于左右子树里，当前 root 就是 LCA；如果只有一个 不为 null，则代表两个节点在同一颗树上，返回这个最先被找到的节点；如果左右都为 null，表示 p,q 都不在这个树上，直接返回 null
#### 26. 二叉树的锯齿形层次遍历
给定一个二叉树，返回其节点值的锯齿形层次遍历。（即先从左往右，再从右往左进行下一层遍历，以此类推，层与层之间交替进行）。
这道题就是牛客网上的“之字形遍历树”，直接用深度遍历即可，处于同样 depth 的节点放进同样的数组中，不过还需判断当前 depth 是偶数还是奇数，偶数则 unshift，奇数则 push
#### 27. 买卖股票的最佳时机/买卖股票的最佳时机 II
这两道题都是起码做了三遍了，结果第一道题还没做出来ORZ。第一题就是找到一个最优的利润，就是遍历数组，找到数组开始到当前项买入最小值，还要找到当前项减去最小值的最大值，最后返回最大值即可。
第二题也很简单，只要后面项比前面项大，则将差值加至total即可。
#### 28. 最大正方形
在一个由 0 和 1 组成的二维矩阵内，找到只包含 1 的最大正方形，并返回其面积。
这个题也就是动态规划，利用一个数组记录结果。对于i,j来说，dp[i][j]表示以 (i, j)为右下角所构成的正方形最大边长，找到 dp[i - 1][j - 1],dp[i][j - 1], dp[i - 1][j] 其中的最小值，+1 则为 dp[i][j] 的最终结果。